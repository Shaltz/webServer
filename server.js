// Generated by CoffeeScript 1.9.0
(function() {
  var conf, contentTypeArray, createErrorPage, createRespHeader, fs, getFileInfos, htmlErrorMessage, net, parseReqHeader, path, processResponse, server, statutCodeArray, _DEBUG, _FOOTER, _PORT, _SERVER_NAME, _SERVER_VERSION, _WEBROOT;

  conf = require('./conf/conf.json');

  net = require('net');

  fs = require('fs');

  path = require('path');

  _SERVER_NAME = 'Wwwaiter';

  _SERVER_VERSION = '0.1.0';

  _PORT = conf['_port'];

  _WEBROOT = conf['_webroot'];

  _FOOTER = conf['_HTML_Footer'];

  _DEBUG = conf['_debug'];

  statutCodeArray = {
    200: 'OK !!',
    404: 'Not Found !!',
    500: 'Internal Server Error !!'
  };

  htmlErrorMessage = {
    404: 'The page you\'re looking for doesn\'t exist !!',
    500: 'The server has encountered an Internal Error !!'
  };

  contentTypeArray = {
    html: 'text/html',
    txt: 'text/plain',
    map: 'text/plain',
    css: 'text/css',
    js: 'application/javascript',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    mp3: 'audio/mpeg3',
    mp4: 'video/mpeg'
  };


  /* OUMPA-LOUMPAS */

  createErrorPage = function(err, errCode) {
    var displayErrorOnDebug, errorMessage, htmlErrorPage;
    if (!errCode) {
      errCode = 500;
    }
    displayErrorOnDebug = _DEBUG ? 'block' : 'none';
    errorMessage = htmlErrorMessage[errCode];
    return htmlErrorPage = "<!DOCTYPE HTML> <html> <head> <meta charset='UTF-8'> <link rel='stylesheet' href='//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css'/> </head> <body> <div align='center'><i class='fa fa-ban fa-5x'></i></div> <div style='height:600px'> <h1 align='center'>ERROR " + errCode + "</h1> <h1 align='center'>" + errorMessage + "</h1> <br> <br> <br> <div style=\"display:" + displayErrorOnDebug + "\" align='center'> " + err + " </div> <br> <br> <br> <br> </div> </body> <footer> <div align='center'>" + _FOOTER + "</div> </footer> </html>";
  };

  createRespHeader = function(statutCode, contentType, realPath, socket, fileStream, callback) {
    return setTimeout(function() {
      var respHeader, statutMessage;
      statutMessage = statutCodeArray[statutCode];
      if (realPath !== void 0) {
        getFileInfos(realPath, function(size, mtime) {
          var respHeader;
          console.log('fileSize :' + fileSize);
          return respHeader = ("HTTP/1.0 " + statutCode + " " + statutMessage + "\r\nContent-Type: " + contentType + "\r\nDate: ") + new Date() + ("\r\nContent-Length: " + size + "\r\n\r\n");
        });
      } else {
        respHeader = "HTTP/1.0 " + statutCode + " " + statutMessage + "\r\nContent-Type: " + contentType + "\r\n\r\n";
      }
      return callback(respHeader, socket, fileStream, 0);
    });
  };

  getFileInfos = function(filePath, callback) {
    return setTimeout(function() {
      var fileSize, lastModified;
      fileSize = null;
      lastModified = null;
      return fs.stat(filePath, function(err, stats) {
        if (err) {
          throw err;
        }
        fileSize = stats['size'];
        lastModified = stats['mtime'];
        return callback(fileSize, lastModified);
      }, 0);
    });
  };

  parseReqHeader = function(reqHeader) {
    var filePath, method, protocol, statusLine, str;
    str = reqHeader.toString('utf8');
    statusLine = str.substr(0, str.indexOf('\r\n'));
    method = statusLine.substr(0, statusLine.indexOf(' '));
    filePath = statusLine.substring(statusLine.indexOf(method) + method.length + 1, statusLine.indexOf(' HTTP'));
    protocol = statusLine.substr(statusLine.indexOf('HTTP'));
    return {
      'statusLine': statusLine,
      'method': method,
      'filePath': filePath,
      'protocol': protocol
    };
  };

  processResponse = function(realPath, socket) {
    var contentType, extension, filePath, fileStream;
    fileStream = fs.createReadStream(realPath);
    filePath = path.normalize(realPath);
    extension = path.extname(filePath);
    extension = extension.substr(1);
    contentType = contentTypeArray[extension];
    fileStream.on('open', function() {
      if (_DEBUG) {
        console.log('FILESTREAM.OPEN : A file has been served !');
      }
      return createRespHeader(200, contentType, realPath, socket, fileStream, function(respHeader, socket, fileStream) {
        return socket.write(respHeader, function() {
          return fileStream.pipe(socket);
        });
      });
    });
    fileStream.on('end', function() {
      return socket.end();
    });
    return fileStream.on('error', function(err) {
      var _errorCode;
      if (_DEBUG) {
        console.error('FILESTREAM.ERROR : An error occured :', err['code']);
      }
      switch (err['code']) {
        case 'ENOENT':
          _errorCode = 404;
          break;
        default:
          _errorCode = 500;
      }
      return createRespHeader(_errorCode, 'text/html', realPath, socket, fileStream, function(respHeader, socket, fileStream) {
        return socket.write(respHeader, function() {
          return socket.end(createErrorPage(err, _errorCode));
        });
      });
    });
  };


  /* WILLY WONKA */

  server = net.createServer(function(socket) {
    socket.on('data', function(reqHeader) {
      var filePath, realPath, _filePath;
      filePath = (parseReqHeader(reqHeader))['filePath'];
      _filePath = filePath === '/' ? 'index.html' : filePath;
      realPath = path.join(_WEBROOT, _filePath);
      return processResponse(realPath, socket);
    });
    return socket.on('error', function(err) {
      if (_DEBUG) {
        return console.error('SOCKET.ERROR : il y a une erreur:', err.toString('utf8'));
      }
    });
  });

  server.listen(_PORT, function() {
    console.log('\n##################\n');
    console.log("WebServer ONline on port: " + _PORT + "\r\n");
    if (_DEBUG) {
      console.log('Date :', new Date());
      console.log('WebRoot :', _WEBROOT);
      console.log('Footer Message :', _FOOTER);
      console.log('Debug Mode:', _DEBUG);
    }
    return console.log('\n##################\n');
  });

}).call(this);
